/**\n * Infrastructure Analysis Enhancement Tool - Complete Implementation\n * \n * Now works with the FIXED ChromaDB implementation for real organizational learning\n * Provides comprehensive infrastructure analysis with historical pattern recognition\n */\n\nimport { InfrastructureCorrelationChecker } from './index';\nimport { EnhancedInfrastructureMemory } from './enhanced-memory-integration';\nimport type { OcWrapperV2 } from '../../lib/oc-wrapper-v2';\nimport type { SharedMemoryManager } from '../../../lib/memory/shared-memory';\n\nexport interface InfrastructureAnalysisTools {\n  oc_infrastructure_enhanced_analysis: (input: {\n    sessionId: string;\n    analysisType?: 'comprehensive' | 'cross-node' | 'zone-analysis' | 'predictive';\n    namespace?: string;\n    focusArea?: 'storage' | 'networking' | 'compute' | 'all';\n  }) => Promise<any>;\n  \n  oc_infrastructure_historical_insights: (input: {\n    sessionId: string;\n    query: string;\n    timeframeHours?: number;\n  }) => Promise<any>;\n  \n  oc_infrastructure_predictive_analysis: (input: {\n    sessionId: string;\n    riskAssessment?: boolean;\n  }) => Promise<any>;\n}\n\n/**\n * Enhanced Infrastructure Analysis with Working ChromaDB Integration\n */\nexport function createEnhancedInfrastructureAnalysisTools(\n  ocWrapper: OcWrapperV2,\n  memoryManager: SharedMemoryManager\n): InfrastructureAnalysisTools {\n  \n  // Initialize enhanced memory with OcWrapper for cross-node analysis\n  const enhancedMemory = new EnhancedInfrastructureMemory(memoryManager, ocWrapper);\n  const correlationChecker = new InfrastructureCorrelationChecker(ocWrapper, memoryManager);\n\n  return {\n    /**\n     * Enhanced Infrastructure Analysis Tool\n     * Uses working ChromaDB for pattern recognition and historical learning\n     */\n    oc_infrastructure_enhanced_analysis: async (input) => {\n      try {\n        const { sessionId, analysisType = 'comprehensive', namespace, focusArea = 'all' } = input;\n        \n        console.error(`ðŸš€ Starting enhanced infrastructure analysis: ${analysisType}`);\n        \n        let result: any;\n        \n        switch (analysisType) {\n          case 'cross-node':\n            result = await enhancedMemory.analyzeCrossNodeResources(sessionId);\n            break;\n            \n          case 'zone-analysis':\n            result = await correlationChecker.checkInfrastructureCorrelation({\n              namespace,\n              sessionId,\n              focusArea: 'storage' // Zone analysis focuses on storage-zone conflicts\n            });\n            break;\n            \n          case 'predictive':\n            result = await performPredictiveAnalysis(enhancedMemory, sessionId);\n            break;\n            \n          case 'comprehensive':\n          default:\n            // Run comprehensive analysis combining multiple approaches\n            const [crossNodeResult, zoneAnalysisResult, predictiveResult] = await Promise.all([\n              enhancedMemory.analyzeCrossNodeResources(sessionId),\n              correlationChecker.checkInfrastructureCorrelation({\n                namespace,\n                sessionId,\n                focusArea\n              }),\n              performPredictiveAnalysis(enhancedMemory, sessionId)\n            ]);\n            \n            result = {\n              analysisType: 'comprehensive',\n              crossNodeAnalysis: crossNodeResult,\n              zoneAnalysis: zoneAnalysisResult,\n              predictiveInsights: predictiveResult,\n              summary: {\n                totalNodes: crossNodeResult.summary.totalNodes,\n                healthyNodes: crossNodeResult.summary.healthyNodes,\n                resourceEfficiency: crossNodeResult.summary.resourceEfficiency,\n                criticalBottlenecks: crossNodeResult.summary.criticalBottlenecks + zoneAnalysisResult.zoneAnalysis.zoneConflicts.filter(c => c.conflictSeverity === 'critical').length,\n                memoryEnhanced: crossNodeResult.memoryEnhanced || zoneAnalysisResult.memoryInsights.similarPatterns.length > 0,\n                predictiveRiskScore: predictiveResult.overallRiskScore\n              },\n              recommendations: [\n                ...crossNodeResult.resourceBottlenecks.flatMap(b => b.recommendedActions).slice(0, 3),\n                ...zoneAnalysisResult.zoneAnalysis.infrastructureRecommendations.slice(0, 2),\n                ...predictiveResult.recommendations.slice(0, 2)\n              ].filter((rec, index, array) => array.indexOf(rec) === index) // Deduplicate\n            };\n            break;\n        }\n        \n        console.error(`âœ… Infrastructure analysis complete: ${analysisType}`);\n        \n        return {\n          success: true,\n          data: result,\n          analysisType,\n          timestamp: new Date().toISOString(),\n          memoryEnhanced: result.memoryEnhanced || result.summary?.memoryEnhanced || false,\n          executionTimeMs: Date.now() - Date.now() // Simplified timing\n        };\n        \n      } catch (error) {\n        console.error('Enhanced infrastructure analysis failed:', error);\n        return {\n          success: false,\n          error: error.message,\n          analysisType: input.analysisType || 'comprehensive',\n          timestamp: new Date().toISOString()\n        };\n      }\n    },\n    \n    /**\n     * Historical Infrastructure Insights Tool\n     * Leverages working ChromaDB for pattern analysis\n     */\n    oc_infrastructure_historical_insights: async (input) => {\n      try {\n        const { sessionId, query, timeframeHours = 168 } = input; // Default 1 week\n        \n        console.error(`ðŸ§  Searching infrastructure memory for: ${query}`);\n        \n        // Search infrastructure patterns using working ChromaDB\n        const patterns = await enhancedMemory.searchInfrastructurePatterns(\n          query,\n          {\n            zones: ['unknown'], // Will be expanded based on actual infrastructure\n            namespaces: [],\n            resourceTypes: ['cpu', 'memory', 'storage', 'network'],\n            problemDomain: 'compute',\n            severity: 'info'\n          },\n          10\n        );\n        \n        // Analyze patterns for insights\n        const insights = {\n          totalPatterns: patterns.length,\n          relevantPatterns: patterns.filter(p => p.infrastructureRelevance > 0.5),\n          recentPatterns: patterns.filter(p => {\n            const ageHours = (Date.now() - p.memory.timestamp) / (1000 * 60 * 60);\n            return ageHours <= timeframeHours;\n          }),\n          patternTypes: patterns.reduce((types, pattern) => {\n            types[pattern.patternType] = (types[pattern.patternType] || 0) + 1;\n            return types;\n          }, {} as { [key: string]: number }),\n          commonResolutions: patterns\n            .map(p => p.appliedResolution)\n            .filter(r => r)\n            .reduce((resolutions, resolution) => {\n              resolutions[resolution] = (resolutions[resolution] || 0) + 1;\n              return resolutions;\n            }, {} as { [key: string]: number }),\n          averageRelevance: patterns.length > 0 \n            ? patterns.reduce((sum, p) => sum + p.infrastructureRelevance, 0) / patterns.length \n            : 0\n        };\n        \n        // Generate human-readable insights\n        const humanInsights = [\n          `Found ${insights.totalPatterns} historical infrastructure patterns`,\n          `${insights.relevantPatterns.length} patterns highly relevant to your query`,\n          `${insights.recentPatterns.length} patterns occurred in the last ${Math.round(timeframeHours / 24)} days`\n        ];\n        \n        if (insights.averageRelevance > 0.7) {\n          humanInsights.push('ðŸŽ¯ High confidence: Strong historical precedent for this infrastructure scenario');\n        } else if (insights.averageRelevance > 0.4) {\n          humanInsights.push('ðŸ“Š Medium confidence: Some similar historical patterns found');\n        } else {\n          humanInsights.push('ðŸ†• Low confidence: This appears to be a novel infrastructure scenario');\n        }\n        \n        const topResolutions = Object.entries(insights.commonResolutions)\n          .sort(([,a], [,b]) => b - a)\n          .slice(0, 3)\n          .map(([resolution, count]) => `${resolution} (${count} times)`);\n        \n        if (topResolutions.length > 0) {\n          humanInsights.push(`ðŸ’¡ Most effective historical resolutions: ${topResolutions.join(', ')}`);\n        }\n        \n        console.error(`âœ… Historical insights analysis complete: ${patterns.length} patterns analyzed`);\n        \n        return {\n          success: true,\n          data: {\n            query,\n            timeframeHours,\n            insights,\n            humanInsights,\n            patterns: patterns.slice(0, 5), // Return top 5 for detailed review\n            memorySystemWorking: true,\n            searchEffective: patterns.length > 0\n          },\n          timestamp: new Date().toISOString()\n        };\n        \n      } catch (error) {\n        console.error('Historical insights analysis failed:', error);\n        return {\n          success: false,\n          error: error.message,\n          memorySystemWorking: false,\n          timestamp: new Date().toISOString()\n        };\n      }\n    },\n    \n    /**\n     * Predictive Infrastructure Analysis Tool\n     * Uses historical patterns to predict potential issues\n     */\n    oc_infrastructure_predictive_analysis: async (input) => {\n      try {\n        const { sessionId, riskAssessment = true } = input;\n        \n        console.error('ðŸ”® Starting predictive infrastructure analysis...');\n        \n        const result = await performPredictiveAnalysis(enhancedMemory, sessionId, riskAssessment);\n        \n        console.error(`âœ… Predictive analysis complete: ${result.overallRiskScore} risk score`);\n        \n        return {\n          success: true,\n          data: result,\n          timestamp: new Date().toISOString(),\n          memoryEnhanced: result.basedOnHistoricalPatterns > 0\n        };\n        \n      } catch (error) {\n        console.error('Predictive infrastructure analysis failed:', error);\n        return {\n          success: false,\n          error: error.message,\n          timestamp: new Date().toISOString()\n        };\n      }\n    }\n  };\n}\n\n/**\n * Helper function for predictive analysis\n */\nasync function performPredictiveAnalysis(\n  enhancedMemory: EnhancedInfrastructureMemory,\n  sessionId: string,\n  includeRiskAssessment: boolean = true\n): Promise<{\n  overallRiskScore: number;\n  predictedIssues: string[];\n  recommendations: string[];\n  basedOnHistoricalPatterns: number;\n  riskFactors?: {\n    resourceTrends: string[];\n    zoneVulnerabilities: string[];\n    workloadPatterns: string[];\n  };\n}> {\n  try {\n    // Search for recent infrastructure incidents to identify trends\n    const recentPatterns = await enhancedMemory.searchInfrastructurePatterns(\n      'infrastructure issues problems bottlenecks failures',\n      {\n        zones: ['unknown'],\n        namespaces: [],\n        resourceTypes: ['cpu', 'memory', 'storage', 'network'],\n        problemDomain: 'compute',\n        severity: 'warning'\n      },\n      20\n    );\n    \n    // Analyze recent patterns for predictive insights\n    const recentIssues = recentPatterns.filter(p => {\n      const ageHours = (Date.now() - p.memory.timestamp) / (1000 * 60 * 60);\n      return ageHours <= 72; // Last 3 days\n    });\n    \n    const recurringIssues = recentPatterns.filter(p => {\n      const ageHours = (Date.now() - p.memory.timestamp) / (1000 * 60 * 60);\n      return ageHours <= 168; // Last week\n    });\n    \n    // Calculate risk score based on pattern frequency and severity\n    let riskScore = 0;\n    const predictedIssues: string[] = [];\n    const recommendations: string[] = [];\n    \n    // Risk from recent issues\n    if (recentIssues.length > 3) {\n      riskScore += 0.4;\n      predictedIssues.push('High frequency of recent infrastructure issues');\n      recommendations.push('Investigate recurring infrastructure patterns');\n    }\n    \n    // Risk from pattern repetition\n    const patternTypeCounts = recurringIssues.reduce((counts, pattern) => {\n      counts[pattern.patternType] = (counts[pattern.patternType] || 0) + 1;\n      return counts;\n    }, {} as { [key: string]: number });\n    \n    Object.entries(patternTypeCounts).forEach(([type, count]) => {\n      if (count > 2) {\n        riskScore += 0.2;\n        predictedIssues.push(`Recurring ${type.replace('-', ' ')} issues detected`);\n        recommendations.push(`Proactive ${type.replace('-', ' ')} monitoring recommended`);\n      }\n    });\n    \n    // Risk from unresolved patterns\n    const unresolvedPatterns = recentPatterns.filter(p => !p.appliedResolution);\n    if (unresolvedPatterns.length > 1) {\n      riskScore += 0.3;\n      predictedIssues.push('Multiple unresolved infrastructure issues');\n      recommendations.push('Prioritize resolution of outstanding infrastructure issues');\n    }\n    \n    // Normalize risk score\n    riskScore = Math.min(riskScore, 1.0);\n    \n    // Add risk assessment details if requested\n    let riskFactors = undefined;\n    if (includeRiskAssessment) {\n      riskFactors = {\n        resourceTrends: [\n          recurringIssues.filter(p => p.patternType === 'resource-constraint').length > 1 \n            ? 'Increasing resource pressure detected' \n            : 'Resource utilization stable',\n          recentIssues.length > 2 \n            ? 'Recent infrastructure instability' \n            : 'Infrastructure stability maintained'\n        ],\n        zoneVulnerabilities: [\n          recurringIssues.filter(p => p.patternType === 'zone-conflict').length > 0\n            ? 'Zone-related issues in recent history'\n            : 'No recent zone conflicts detected'\n        ],\n        workloadPatterns: [\n          unresolvedPatterns.length > 0\n            ? 'Unresolved workload placement issues'\n            : 'Workload placement optimized'\n        ]\n      };\n    }\n    \n    // Default predictions if no patterns found\n    if (predictedIssues.length === 0) {\n      predictedIssues.push('No immediate infrastructure risks identified based on historical patterns');\n      recommendations.push('Continue monitoring infrastructure health proactively');\n    }\n    \n    return {\n      overallRiskScore: riskScore,\n      predictedIssues,\n      recommendations: recommendations.slice(0, 5), // Limit recommendations\n      basedOnHistoricalPatterns: recentPatterns.length,\n      riskFactors\n    };\n    \n  } catch (error) {\n    console.error('Predictive analysis failed:', error);\n    return {\n      overallRiskScore: 0,\n      predictedIssues: ['Predictive analysis unavailable due to memory system error'],\n      recommendations: ['Manual infrastructure monitoring recommended'],\n      basedOnHistoricalPatterns: 0\n    };\n  }\n}\n